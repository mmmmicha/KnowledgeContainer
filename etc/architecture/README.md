# ARCHITECTURE PATTERN
## 레이어 패턴(Layers pattern)
- 시스템을 계층으로 구분하여 구성하는 방법
- 마주보는 두 개의 계층만 상호작용이 가능
- 특정계층만 교체해 시스템을 개선하는 것이 가능
- ex) OSI 참조 모델
- `Layered Architecture`라고도 함
    - [기초 아티클](https://hudi.blog/layered-architecture/)
- `4-tier layer`를 많이 사용하는 편이다.
    - `presentation`: view, controller
    - `business`: service, domain model
    - `persistence`: repository, dao
    - `database`: database
## 클라이언트-서버 패턴(Client-Server pattern)
- 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
- 사용자 -> 클라이언트 -> 서버 -> 클라이언트 -> 사용자
- 서버는 클라이언트 요청에 대비해 항상 대기상태 유지
- 클라이언트나 서버는 요청과 응답을 위해 동기화되는 경우를 제외하면 서로 독립적!
## 파이프-필터 패턴(Pipe-Filter Pattern)
- 데이터 스트림 절차의 각 단계를 필터(Filter) 컴포넌트로 캡슐화하여 파이프(Pipe)를 통해 데이터를 전송하는 패턴
- 필터 컴포넌트의 재사용성, 확장 용이성
- 필터 컴포넌트의 재배치로 다양한 구축 가능
- 데이터변환, 버퍼링, 동기화 등에 사용
- ex) UNIX 의 쉘(Shell)
## 모델-뷰-컨트롤러 패턴(MVC Pattern : Model-View-Controller Pattern)
- 서브시스템을 3개의 부분으로 구조화하는 패턴
    - 모델(Model) : 서브시스템의 핵심 기능과 데이터를 보관
    - 뷰(View) : 사용자에게 정보를 표시
    - 컨트롤러(Controller) : 사용자로부터 받은 입력을 처리
- 서로 영향을 받지않고 개별작업 수행 가능
- 한 개의 모델에 여러 개의 뷰를 필요로 하는 '대화형 어플리케이션' 에 적합
## 마스터-슬레이브 패턴(Master-Slave Pattern)
- 마스터 컴포넌트에서 슬레이브 컴포넌트로 작업을 분할한 후, 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식
    - 마스터 컴포넌트 : 모든 작업의 주체
    - 슬레이브 컴포넌트 : 지시에 따라 작업을 수행 후 결과 반환
- ex) 장애허용시스템, 병렬 컴퓨팅 시스템
## 브로커 패턴(Broker Pattern)
- 사용자가 브로커 컴포넌트에 요청 시 요청에 맞는 컴포넌트와 사용자를 연결
- 원격 서비스 호출에 응답하는 컴포넌트들이 여러 개 있을 때 적합한 패턴
- ex) 분산 환경 시스템
## 피어-투-피어 패턴
- 피어(Peer)를 하나의 컴포넌트로 간주함
- 각 피어는 서비스를 호출하는 클라이언트가 될수도, 서비스를 제공하는 서버가 될 수도 있는 패턴
- 클라이언트와 서버는 전형적인 '멀티스레딩(multi-threading)'방식을 사용
## 이벤트-버스 패턴(Event-Bus Pattern)
- 소스가 특정 채널에 이벤트 메시지를 발행(publish)하면, 해당 채널을 구독(subscribe)한 리스너들이 메시지를 받아 이벤트를 처리
- 4가지 주요 컴포넌트
    - 이벤트를 생성하는 소스(Source)
    - 이벤트를 수행하는 리스너(Listener)
    - 이벤트의 통로인 채널(Channel)
    - 채널들을 관리하는 버스(Bus)
## 블랙보드 패턴(BlackBoard Pattern)
- 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태
- 컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있음
- 해결책이 명확하지 않은 문제처리에 유용
- ex) 음성인식, 차량식별, 신호해석 등...
## 인터프리터 패턴(Interpreter Pattern)
- 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성
- 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용